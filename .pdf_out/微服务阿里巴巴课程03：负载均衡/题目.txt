=== 第 1 页 ===

微服务阿里巴巴课程03：负载均衡
 
一、负载均衡器Ribbon
 
1.1、Ribbon基本概念
 
1.1.1 ribbon负载均衡概念
 
负载均衡的概念
负载均衡是指单台服务器性能达到极限时，通过服务器集群来横向增加系统的吞吐量和性能。
目前主流的负载均衡方案，分为以下两种：
第一种方式：集中式负载均衡（也叫服务端的负载均衡）：
集中式负载均衡是在消费者和提供者中间使用独立的代理方式进项负载，有硬件的（例如：
F5），也有软件的（例如：Nginx）。
第二种方式：客户端的负载均衡
客户端根据自己的请求情况做负载均衡，ribbon就属于客户端自己做负载均衡。
spring cloud ribbon是基于netflix ribbon实现的一套客户端的负载均衡工具，ribbon会自动基于
某种规则（轮询）去调用这些服务。
1.1.2 负载均衡升级
 
由于原有的负载均衡组件Ribbon停止维护，所以SpringCloud2020版本以后，官方自己造出了
Spring Cloud LoadBalancer来代替Ribbon。
Spring Cloud LoadBalancer已经实现了RoundBobinLoadBalancer(轮询策略)和
RandomLoadBalancer(随机策略)
1.2、客户端的负载均衡
 
以spring cloud中的ribbon为例，客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选
择一个服务器，然后进行访问，这是客户端负载均衡，即在客户端就进行负载均衡算法分配。



=== 第 2 页 ===

1.3、服务端的负载均衡
 
例如nginx，通过nginx进行负载均衡，先发送请求，然后通过负载 均衡算法，在多个服务器之间选择
一个进行访问，即在服务器端再进行负载均衡算法分配。（这个需要在nginx中配置负载均衡策略）
1.4、常见负载均衡算法
 
轮询：负载均衡默认实现方式，请求来了之后排队处理。
随机：通过随机选择服务进行执行，一般这种方式使用的比较少。
权重算法：权值越高，被分配的请求就越多，通过对服务器性能的分析，给高配置、低负载的服务
器分配更高的权重，均衡各个服务器的压力。
地址Hash：通过客户端请求的地址的Hash值取模映射进行服务器调度。
根据ip地址进行hash得到一个数值，用这个数值进行取模（服务器数量就是取模的底数），
最终利用得到的余数进行负载均衡。计算公式：hash(ip)%服务器数量
hash(ip)=100，101，102       100%3=1  101%3=2 102%3=0
1.5 常见负载均衡策略
 
从上图可以看出：我们所有的负载均衡策略都需要实现IRule接口，而每一个实现类都是一种负载
均衡策略
1、轮询策略——RoundRobinRule，也是Ribbon的默认策略
2、随机策略——RandomRule：随机选择一个server
3、权重策略——NacosRule：给服务器设置权重，权重越大，被选中的概率也越大。
 
二、Spring Cloud 2022负载均衡
 
2.1 搭建服务提供者环境
 
2.1.1 配置依赖
 
Spring Cloud2022要使用负载均衡策略，需要在公共模块（common-api）中配置如下依赖（也
可以只配置在服务消费者端）：



=== 第 3 页 ===

 
2.1.2 搭建提供者集群(方法一)
 
搭建提供者集群（同一个服务提供者复制成三个服务提供者stock-service），用于测试消费者发出
请求时，按照不同的负载均衡策略，调用不同的服务提供者，从而查看具体结果。
通过复制原来的stock-service项目，创建出新的stock-service2，stock-service3项目，注意
如下调整：
复制项目以后拷贝到父项目目录下并修改成目标项目名，中途可能会提示没有找到
application.yml文件（该文件被改成了bootstrap.yml），这个不用理会，然后导入项
目，在导入时也将名称修改成目标项目名。
删除项目中多余的原来项目的iml文件（stock-nacos.iml）
修改bootstrap.yml文件，将服务端口改成9002，注意不要修改应用名称，三个提供者
的应用名称都相同（stock-service）
修改启动类名称（改为StockServiceApplication9002），便于运行时区分。
修改pom.xml文件中的artifactId，取值是当前项目名称（stock-service2）
在父项目的pom.xml文件中添加一个mudel，将这里的artifactId名称配置进去，表示该
项目归父项目管理
修改控制器，添加上服务端口的显示，便于测试时看到端口，从而确定具体提供者
<!--添加负载均衡的依赖,2022以后的版本需要单独配置-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
@RestController
@RequestMapping("/stock")
public class StockController {
    
    @Value("${server.port}")
    private Integer port;
    
    @RequestMapping("/updateStock")
    public String updateStock(){
        System.out.println("------进入了StockController的updateStock方法-
-------");
        //修改数据库中的库存，这里就不演示了。
        //库存提供者提供的数据
        return "my stock success,port:"+port;
    }
}  



=== 第 5 页 ===

 
 
2.1.3 搭建提供者集群(方法二)
 
因为通过复制项目的方式创建新项目很容易出问题，所以建议直接通过创建项目的方式实现搭建服
务提供者集群
2.1.3.1 创建项目
 
搭建提供者集群（通过手动创建mudule的方式进行），用于测试消费者发出请求时，按照不同的
负载均衡策略，调用不同的服务提供者，从而查看具体结果。
创建服务提供者模块



=== 第 6 页 ===

配置依赖：这里可以直接到stock-service的pom.xml文件中复制对应依赖。
创建全局配置文件（application.yml），并从stock-service中复制对应配置。
注意：必须修改当前项目使用的端口号，另外服务名称必须和前面的stock-service中
的服务名称相同
<dependencies>
    <dependency>
        <groupId>com.baidu</groupId>
        <artifactId>common-api</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
</dependencies>
server:
  port: 9002
spring:
  application:
    name: stock-service
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/gz01?serverTimezone=UTC
    username: root
    password: xiaoye
mybatis-plus:
  type-aliases-package: com.baidu.pojo
  mapper-locations: classpath:/mappers/*.xml



=== 第 7 页 ===

创建启动器
 
实现功能：这里可以直接到stock-service项目，将对应功能的代码复制过来。
 
   
 
2.1.3.2 项目调整
 
在配置服务提供者的服务名称时，一定要保证三个提供者的应用名称都相同（stock-service）
每个服务提供者必须使用自己独立的端口。
为了能够查看到具体是那一个服务提供者提供服务，所以在服务服务提供着的StockController控
制器中添加一个测试方法，并返回当前服务提供者的端口号。
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
@SpringBootApplication
public class StockService2Application9002 {
    public static void main(String[] args) {
        SpringApplication.run(StockService2Application9002.class,args);
    }
}
@RestController
@RequestMapping("/stock")
public class StockController {
    @Autowired
    private StockService service;
    
    @Value("${server.port}")
    private Integer port;
    
    @RequestMapping("/testCluster")
    public String testClu(){
        System.out.println("-----testClu-------");
        
        return "服务提供者调用成功，当前服务提供者的端口port="+port;



=== 第 8 页 ===

 
2.2 搭建服务消费者环境
 
只需要到order-web项目的控制器（OrderController）添加如下处理请求的方法：
 
 
2.3 实现轮询策略
 
2.3.1 配置负载均衡策略
 
因为Spring Cloud LoadBalancer默认使用的是轮询策略，所以服务消费者不需要做任何配置
2.3.2 测试轮询策略
 
先启动nacos注册中心，然后启动三个服务提供者（stock-service）和服务消费者（order-web）
打开nacos注册中心管理平台，打开服务列表，可以查看到如下结果
    }
    
    。。。。。。。。。。。。。。。
}
@RestController
@RequestMapping("/order")
public class OrderController {
    @Autowired
    private RestTemplate restTemplate;
    //测试服务消费者调用服务提供者集群
    @RequestMapping("/test")
    public String test(){
        System.out.println("------test-------");
        String url="http://stock-service/stock/testCluster";
        //执行远程调用
        String res=restTemplate.getForObject(url,String.class);
        System.out.println("res:"+res);
        return "消费者调用成功，"+res;
    }



=== 第 9 页 ===

在浏览器中输入请求地址：http://localhost:8001/order/test，多次刷新页面，查看页面中端口值
变化，可以看出负载均衡的策略。
 
2.4 实现随机策略
 
2.4.1 配置随机策略
 
在服务消费者的com.baidu.config包中，创建LoadBalancerConfig类，用于配置随机策略，具体
代码如下：
注意：该配置类不需要添加@Configuration注解
ServiceInstance表示服务实例。
LoadBalancerClientFactory表示负载均衡的客户端工厂，该工厂生产客户端，通过负载均衡
和客户端生成客户端实例。
ServiceInstanceListSupplier是一个服务实例列表提供者接口，它的主要作用是根据服务名或其他
条件来获取可用的服务实例列表。在微服务架构中，服务实例可能会动态地注册和注销，而
ServiceInstanceListSupplier则负责提供当前可用的服务实例信息。
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.loadbalancer.core.RandomLoadBalancer;
import org.springframework.cloud.loadbalancer.core.ReactorLoadBalancer;
import 
org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;
import 
org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.core.env.Environment;
public class LoadBalancerConfig {
    @Bean
    public ReactorLoadBalancer<ServiceInstance> getBalancer(Environment env,



=== 第 10 页 ===

 
2.4.2 使用随机策略
 
方法一：局部使用，针对指定服务提供者，实现随机策略，只需要在RestTemplateConfig中添加
如下注解：
方法二：全局配置：如果需要对所有服务提供者都使用随机策略，则可以在springboot的启动器
上添加如下注解：
                                                           
 LoadBalancerClientFactory factory) {
        //获取服务提供者的服务名称
        String name=env.getProperty(factory.PROPERTY_NAME);
        System.out.println("name-----------"+name);
        //获取ObjectProvider对象
        ObjectProvider<ServiceInstanceListSupplier> 
provider=factory.getLazyProvider(name, ServiceInstanceListSupplier.class);
        //返回随机策略对象
        return new RandomLoadBalancer(provider,name);
    }
}
//value配置服务提供者的服务名称，configuration配置负载均衡策略的配置类名称
@LoadBalancerClient(value = "stock-service", configuration = 
LoadBalancerConfig.class)
package com.baidu.config;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.loadbalancer.annotation.LoadBalancerClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;
@Configuration
//value配置服务提供者的服务名称，configuration配置负载均衡策略的配置类名称
@LoadBalancerClient(value = "stock-service", configuration = 
LoadBalancerConfig.class)
public class RestTemplateConfig {
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate() {
        return  new RestTemplate();
    }
}
@LoadBalancerClients(defaultConfiguration = LoadBalancerConfig.class)
package com.baidu;



=== 第 11 页 ===

 
2.4.3 测试功能
 
先启动nacos注册中心，启动三个服务提供者(stock-service)，启动服务消费者(order-web)，最后
在浏览器中输入地址：http://localhost:8001/order/test，多次刷新地址栏，查看运行结果，发现
提供服务的端口是没有规律的。
2.5 实现权重策略
 
2.5.1 配置服务提供者的权重
 
进入每一个服务提供者(stock-service)，通过在application.yml文件中添加如下配置，从而设置权
重，权重取值范围是1--100之间。
例如配置stock-service项目权重，application.yml文件的完整代码如下：
import com.baidu.config.LoadBalancerConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import 
org.springframework.cloud.loadbalancer.annotation.LoadBalancerClients;
@SpringBootApplication
@LoadBalancerClients(defaultConfiguration = LoadBalancerConfig.class)
public class OrderWebApplication8001 {
    public static void main(String[] args) {
        SpringApplication.run(OrderWebApplication8001.class, args);
    }
}
spring:
  cloud:
    nacos:
      discovery:
        weight: 50



=== 第 12 页 ===

配置完成以后，进入nacos的服务列表，点击详情，查看结果如下：
 
 
2.5.2 配置权重策略
 
在服务消费者的com.baidu.config包中，创建NacosLoadBalancerConfig类，用于配置权重策
略，具体代码如下：
注意：该配置类不需要添加@Configuration注解
注意：这里需要注入NacosDiscoveryProperties对象，在创建NacosLoadBalancer对象时会
用到相关的配置信息。
server:
  port: 9001
  tomcat:
    uri-encoding: UTF-8
spring:
  application:
    name: stock-service
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
        weight: 1
package com.baidu.config;
import com.alibaba.cloud.nacos.NacosDiscoveryProperties;
import com.alibaba.cloud.nacos.loadbalancer.NacosLoadBalancer;
import jakarta.annotation.Resource;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.loadbalancer.core.ReactorLoadBalancer;
import 
org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;
import 
org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.core.env.Environment;
public class NacosLoadBalancerConfig {



=== 第 13 页 ===

 
2.5.3 使用权重策略
 
方法一：局部使用，针对指定服务提供者，实现权重策略，只需要在RestTemplateConfig中进行
如下配置：
方法二：全局配置：如果需要对所有服务提供者都使用权重策略，则可以在springboot的启动器
上进行如下配置：
    @Resource //这里只能用@Resource注入，不能用@Autowired注入
    private NacosDiscoveryProperties nacosDiscoveryProperties;
    @Bean
    public ReactorLoadBalancer<ServiceInstance> getBalancer(Environment env,
                                                           
 LoadBalancerClientFactory factory){
        System.out.println("nacosDiscoveryProperties--------
"+nacosDiscoveryProperties);
        //获取付提供者的服务名称
        String name=env.getProperty(factory.PROPERTY_NAME);
        //获取ObjectProvider对象
        ObjectProvider<ServiceInstanceListSupplier> provider = 
factory.getLazyProvider(name,ServiceInstanceListSupplier.class);
        //返回NacosLoadBalancer对象
        return new NacosLoadBalancer(provider,name, 
nacosDiscoveryProperties);
    }
}
package com.baidu.config;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.loadbalancer.annotation.LoadBalancerClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;
@Configuration
//value配置服务提供者的服务名称，configuration配置负载均衡策略的配置类名称
@LoadBalancerClient(value = "stock-service", configuration = 
NacosLoadBalancerConfig.class)
public class RestTemplateConfig {
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate() {
        return  new RestTemplate();
    }
}
package com.baidu;



=== 第 14 页 ===

 
2.5.4 测试权重策略：
 
先启动nacos注册中心，启动三个服务提供者(stock-service)，启动服务消费者(order-web)，最后
在浏览器中输入地址：http://localhost:8001/order/test，多次刷新地址栏，查看运行结果，发现
提供服务的端口是9003出现的次数最多，9001端口出现次数最少。
import com.baidu.config.LoadBalancerConfig;
import com.baidu.config.NacosLoadBalancerConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.loadbalancer.annotation.LoadBalancerClient;
import 
org.springframework.cloud.loadbalancer.annotation.LoadBalancerClients;
@SpringBootApplication
@LoadBalancerClients(defaultConfiguration = NacosLoadBalancerConfig.class)
public class OrderWebApplication8001 {
    public static void main(String[] args) {
        SpringApplication.run(OrderWebApplication8001.class, args);
    }
}


